"""
Main entry point for the CodeConCat CLI application.

This module handles command-line argument parsing, configuration loading,
file collection, processing, and output generation.
"""

import os
import sys
import argparse
import logging
import importlib.resources

from tqdm import tqdm

from codeconcat.base_types import AnnotatedFileData, CodeConCatConfig
from codeconcat.collector.github_collector import collect_github_files
from codeconcat.collector.local_collector import collect_local_files
from codeconcat.config.config_loader import load_config
from codeconcat.parser.doc_extractor import extract_docs
from codeconcat.parser.file_parser import parse_code_files
from codeconcat.transformer.annotator import annotate
from codeconcat.writer.markdown_writer import write_markdown
from codeconcat.writer.json_writer import write_json
from codeconcat.writer.xml_writer import write_xml
from codeconcat.version import __version__
from codeconcat.quotes import get_random_quote

# Suppress HuggingFace tokenizers parallelism warning
os.environ["TOKENIZERS_PARALLELISM"] = "false"

#!/usr/bin/env python3
# SPDX‑License‑Identifier: MIT

# ------------------------------------------------------------------------------

logger = logging.getLogger("codeconcat")


# ──────────────────────────────────────────────────────────────────────────────
# Exception hierarchy
# ──────────────────────────────────────────────────────────────────────────────
class CodeConcatError(Exception):
    """Base exception for CodeConCat."""


class ConfigurationError(CodeConcatError):
    pass


class FileProcessingError(CodeConcatError):
    pass


class OutputError(CodeConcatError):
    pass


# ──────────────────────────────────────────────────────────────────────────────
# Helpers
# ──────────────────────────────────────────────────────────────────────────────
def _write_output_files(output_text: str, config: CodeConCatConfig) -> None:
    """Write the final concatenated output to one or more files.

    Handles splitting the output into multiple parts if requested in the config
    (currently only for Markdown format) and optionally copies the content
    to the clipboard.

    Args:
        output_text: The complete string output generated by CodeConCat.
        config: The CodeConCatConfig object containing output settings like
                output path, format, split_output, and disable_copy.
    """
    output_path = config.output or f"code_concat_output.{config.format}"
    parts = max(1, getattr(config, "split_output", 1))

    if parts > 1 and config.format == "markdown":
        lines = output_text.splitlines(keepends=True)
        chunk_size = (len(lines) + parts - 1) // parts
        base, ext = os.path.splitext(output_path)

        # Wrap loop with tqdm for progress
        write_iterator = tqdm(
            range(parts),
            desc="Writing output chunks",
            unit="chunk",
            total=parts,
            disable=config.disable_progress_bar,
        )
        for idx in write_iterator:
            chunk = "".join(lines[idx * chunk_size : (idx + 1) * chunk_size])
            chunk_file = f"{base}.part{idx + 1}{ext}"
            with open(chunk_file, "w", encoding="utf-8") as fh:
                fh.write(chunk)
            logger.info("Output chunk %d/%d → %s", idx + 1, parts, chunk_file)
        print("✔ Output split into", parts, "chunks.")
    else:
        with open(output_path, "w", encoding="utf-8") as fh:
            fh.write(output_text)
        logger.info("Output written → %s", output_path)
        print("✔ Output written to:", output_path)

    # Handle clipboard copy if enabled
    if not getattr(config, "disable_copy", True) and parts <= 1:
        try:
            import pyperclip

            pyperclip.copy(output_text)
            logger.info("Output copied to clipboard.")
        except ImportError:
            logger.warning("pyperclip not installed, skipping clipboard copy.")
        except Exception as e:
            logger.warning(f"Failed to copy to clipboard: {e}")


def create_default_config() -> None:
    """Creates a default '.codeconcat.yml' configuration file in the current directory.

    This function is typically triggered by the '--init' CLI flag.
    It reads the default configuration template embedded within the package
    and writes it to '.codeconcat.yml' in the current working directory.
    If the file already exists, it logs a warning and does not overwrite it.
    """
    config_filename = ".codeconcat.yml"
    if os.path.exists(config_filename):
        logger.warning(f"{config_filename} already exists; aborting.")
        return

    try:
        template_content = importlib.resources.read_text(
            "codeconcat.config", "default_config.template.yml"
        )

        with open(config_filename, "w") as f:
            f.write(template_content)

        logger.info(f"Created default configuration file: {config_filename}")
    except FileNotFoundError:
        logger.error("Default configuration template not found within the package.")
    except Exception as e:
        logger.error(f"Failed to create default configuration file: {e}")


# ──────────────────────────────────────────────────────────────────────────────
# CLI
# ──────────────────────────────────────────────────────────────────────────────
def build_parser() -> argparse.ArgumentParser:
    """Builds and returns the command-line argument parser for CodeConCat.

    Defines all available CLI flags, options, and their help messages,
    organizing them into logical groups for better readability.

    Returns:
        An configured argparse.ArgumentParser instance.
    """
    parser = argparse.ArgumentParser(
        prog="codeconcat",
        description="CodeConCat – LLM‑friendly code aggregator & doc extractor",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    # positional
    parser.add_argument(
        "target_path", nargs="?", default=".", help="Directory to process."
    )

    # version + misc
    parser.add_argument(
        "--version", action="version", version=f"%(prog)s {__version__}"
    )
    parser.add_argument(
        "--show-skip", action="store_true", help="Show skipped files list."
    )
    parser.add_argument("--debug", action="store_true", help="Enable debug logging.")
    parser.add_argument(
        "--log-level",
        default="WARNING",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Base logging level when --debug is absent.",
    )
    parser.add_argument(
        "--init", action="store_true", help="Create default config and exit."
    )
    parser.add_argument(
        "--show-config", action="store_true", help="Print merged config and exit."
    )

    # input
    g_in = parser.add_argument_group("Input Source")
    g_in.add_argument("--github", help="GitHub URL or owner/repo shorthand.")
    g_in.add_argument("--github-token", help="PAT for private repos.")
    g_in.add_argument("--ref", help="Branch, tag or commit hash.")

    # filtering
    g_filt = parser.add_argument_group("Filtering Options")
    g_filt.add_argument(
        "-ip",
        "--include-paths",
        nargs="*",
        help="Glob patterns for files/directories to explicitly include.",
        metavar="PATTERN",
    )
    g_filt.add_argument(
        "-ep",
        "--exclude-paths",
        nargs="*",
        help="Glob patterns for files/directories to explicitly exclude.",
        metavar="PATTERN",
    )
    g_filt.add_argument(
        "--use-gitignore",
        action=argparse.BooleanOptionalAction,
        default=None,  # Default is handled by CodeConCatConfig
        help="Respect .gitignore files (default: True). Use --no-use-gitignore to disable.",
    )
    g_filt.add_argument(
        "--use-default-excludes",
        action=argparse.BooleanOptionalAction,
        default=None,  # Default is handled by CodeConCatConfig
        help="Use built-in default excludes (default: True). Use --no-use-default-excludes to disable.",
    )
    g_filt.add_argument(
        "-il",
        "--include-languages",
        nargs="+",
        metavar="LANG",
        help="Languages to include (e.g., python, java). Overrides default/config.",
    )
    g_filt.add_argument(
        "-el",
        "--exclude-languages",
        nargs="+",
        metavar="LANG",
        help="Languages to exclude (e.g., python, java). Overrides default/config.",
    )

    # output
    g_out = parser.add_argument_group("Output")
    g_out.add_argument("-o", "--output", help="Output file path.")
    g_out.add_argument(
        "--format", default="markdown", choices=["markdown", "json", "xml", "text"]
    )
    g_out.add_argument(
        "--preset",
        choices=["lean", "medium", "full"],
        help="Apply a predefined set of output configuration options (overrides individual flags).",
    )
    g_out.add_argument(
        "--split-output", type=int, metavar="N", default=1, help="Split Markdown."
    )
    g_out.add_argument(
        "--sort-files", action="store_true", help="Sort files alphabetically."
    )

    # feature toggles
    g_feat = parser.add_argument_group("Feature Toggles")
    g_feat.add_argument("--docs", action="store_true", help="Extract standalone docs.")
    g_feat.add_argument(
        "--merge-docs", action="store_true", help="Merge docs into main output."
    )
    g_feat.add_argument(
        "--no-tree", action="store_true", help="Omit folder tree in output."
    )
    g_feat.add_argument(
        "--no-ai-context", action="store_true", help="Skip AI preamble."
    )
    g_feat.add_argument(
        "--no-annotations", action="store_true", help="Skip code annotation."
    )
    g_feat.add_argument("--no-symbols", action="store_true", help="Skip symbol index.")
    g_feat.add_argument(
        "--remove-docstrings", action="store_true", help="Strip docstrings."
    )
    g_feat.add_argument(
        "--cross-link-symbols",
        action="store_true",
        help="Cross‑link symbol list ↔ definitions.",
    )
    g_feat.add_argument(
        "--no-progress-bar", action="store_true", help="Disable tqdm progress bars."
    )

    # output & logging
    g_out_log = parser.add_argument_group("Output & Logging")
    g_out_log.add_argument(
        "--verbose", action="store_true", help="Enable verbose debug logging."
    )

    # processing
    parser.add_argument("--max-workers", type=int, default=4, help="Thread‑pool size.")

    return parser


# ──────────────────────────────────────────────────────────────────────────────
def cli_entry_point() -> None:
    """The main command-line interface entry point for CodeConCat.

    Parses command-line arguments, sets up logging, handles special flags
    like --init and --show-config, loads the configuration, runs the main
    CodeConCat logic via run_codeconcat_in_memory, and writes the output.
    Handles potential errors and logs them appropriately.
    """
    print(get_random_quote())

    parser = build_parser()
    args = parser.parse_args()

    # logging setup
    level = (
        logging.DEBUG
        if args.debug or args.verbose
        else getattr(logging, args.log_level, logging.WARNING)
    )
    logging.basicConfig(level=level, format="%(levelname)s %(name)s: %(message)s")
    logger.setLevel(level)

    # early exits
    if args.init:
        create_default_config()
        sys.exit(0)

    if args.show_config:
        merged = load_config({k: v for k, v in vars(args).items() if v is not None})
        print("--- Final merged configuration ---\n", merged)
        sys.exit(0)

    # merge CLI → pydantic config
    config = load_config(vars(args))
    # Add show_skip to config for downstream functions
    config.show_skip = args.show_skip  # type: ignore[attr-defined]

    try:
        output_text = run_codeconcat(config)
        _write_output_files(output_text, config)
    except CodeConcatError as exc:
        logger.error("Operation failed: %s", exc)
        sys.exit(1)
    except Exception as exc:
        logger.critical("Unexpected error occurred: %s", exc, exc_info=True)
        sys.exit(1)


def generate_folder_tree(root_path: str, config: CodeConCatConfig) -> str:
    """
    Walk the directory tree starting at root_path and return a string representing the folder structure.

    Respects exclusion patterns defined in the config (default and user-defined).
    Uses characters like '│', '├', '└', and '─' to create a visual tree.

    Args:
        root_path: The root directory to start generating the tree from.
        config: The CodeConCatConfig object containing exclusion patterns.

    Returns:
        A string representing the folder structure, ready for inclusion in output.
    """
    from codeconcat.collector.local_collector import (
        should_include_file,
        should_skip_dir,
    )

    lines = []
    for root, dirs, files in os.walk(root_path):
        # Check if we should skip this directory
        if should_skip_dir(root, config):
            dirs[:] = []  # Clear dirs to prevent descending into this directory
            continue

        level = root.replace(root_path, "").count(os.sep)
        indent = "    " * level
        folder_name = os.path.basename(root) or root_path
        lines.append(f"{indent}{folder_name}/")

        # Filter files based on exclusion patterns
        included_files = [
            f for f in files if should_include_file(os.path.join(root, f), config)
        ]

        sub_indent = "    " * (level + 1)
        for f in sorted(included_files):
            lines.append(f"{sub_indent}{f}")

        # Filter directories for the next iteration
        dirs[:] = [
            d for d in dirs if not should_skip_dir(os.path.join(root, d), config)
        ]
        dirs.sort()  # Sort directories for consistent output

    return "\n".join(lines)


def run_codeconcat(config: CodeConCatConfig) -> str:
    """Runs the main CodeConCat processing pipeline and returns the output string.

    This function orchestrates the core steps:
    1. Collects files (local or GitHub).
    2. Parses collected code files.
    3. Extracts documentation files (if enabled).
    4. Performs AI-based annotation (if enabled).
    5. Generates the final output string in the specified format.

    Args:
        config: The fully resolved CodeConCatConfig object containing all settings.

    Returns:
        The concatenated and processed output as a single string.

    Raises:
        CodeConcatError: For general errors during processing.
        ConfigurationError: If the configuration is invalid.
        FileProcessingError: For errors related to reading or parsing files.
        OutputError: For errors during output generation.
    """
    logger.debug("Running CodeConCat with config: %s", config)
    try:
        # Validate configuration
        if not config.target_path:
            raise ConfigurationError("Target path is required")
        if config.format not in ["markdown", "json", "xml", "text"]:
            raise ConfigurationError(f"Invalid format: {config.format}")

        # Collect files
        logger.debug(
            f"Starting file collection from: {config.target_path or config.github_url}"
        )
        try:
            temp_repo_path = ""  # Initialize for non-github case
            if config.github_url:
                code_files, temp_repo_path = collect_github_files(
                    config.github_url, config
                )
            else:
                code_files = collect_local_files(config.target_path, config)

            if not code_files:
                raise FileProcessingError("No files found to process")
        except Exception as e:
            raise FileProcessingError(f"Error collecting files: {str(e)}")
        logger.debug(f"Collected {len(code_files)} files.")

        # Generate folder tree if enabled
        logger.info("[CodeConCat] Generating folder tree...")
        folder_tree_str = ""
        if not config.disable_tree:
            # Use the temporary repo path for GitHub runs, otherwise the target path
            tree_root = temp_repo_path if config.github_url else config.target_path
            try:
                folder_tree_str = generate_folder_tree(tree_root, config)  # Pass config
                logger.info("[CodeConCat] Folder tree generated.")
            except Exception as e:
                logger.warning(f"Warning: Failed to generate folder tree: {str(e)}")

        # Parse code files
        logger.debug("Starting file parsing.")
        try:
            logger.info(
                f"[CodeConCat] Found {len(code_files)} code files. Starting parsing..."
            )
            # Pass the full ParsedFileData objects, which include content
            parsed_files, errors = parse_code_files(code_files, config)
            if errors:
                # Log errors encountered during parsing
                for error in errors:
                    logger.warning(f"Parsing error for {error.file_path}: {str(error)}")

            if not parsed_files:
                logger.error("[CodeConCat] No files were successfully parsed.")
                # Decide if this should be a fatal error or just a warning
                raise FileProcessingError("No files were successfully parsed")
            else:
                logger.info(
                    f"[CodeConCat] Parsing complete. Parsed {len(parsed_files)} files."
                )

        except Exception as e:
            raise FileProcessingError(f"Error parsing files: {str(e)}")

        # Extract docs if requested
        docs = []
        if config.extract_docs:
            try:
                doc_paths = [f.file_path for f in code_files]
                docs = extract_docs(doc_paths, config)
            except Exception as e:
                logger.warning(f"Warning: Failed to extract documentation: {str(e)}")

        logger.info("[CodeConCat] Starting annotation of parsed files...")
        # Annotate files if enabled
        try:
            annotated_files = []
            if not config.disable_annotations:
                # Wrap annotation loop with tqdm
                annotation_iterator = tqdm(
                    parsed_files,
                    desc="Annotating files",
                    unit="file",
                    total=len(parsed_files),
                    disable=config.disable_progress_bar,  # Use config flag
                )
                for file in annotation_iterator:
                    try:
                        annotated = annotate(file, config)
                        annotated_files.append(annotated)
                    except Exception as e:
                        # DEBUG: Log type and value of 'file' before using file.file_path
                        logger.error(
                            f"DEBUG: Annotation exception for file object. Type: {type(file)}, Value: {repr(file)}"
                        )
                        try:
                            file_path_debug = file.file_path
                        except Exception as path_exc:
                            file_path_debug = f"<unavailable: {path_exc}>"
                        logger.warning(
                            f"Warning: Failed to annotate {file_path_debug}: {str(e)}"
                        )
                        # Fall back to basic annotation
                        try:
                            annotated_files.append(
                                AnnotatedFileData(
                                    file_path=file.file_path,
                                    language=file.language,
                                    content=file.content,
                                    annotated_content=file.content,
                                    summary="",
                                    tags=[],
                                )
                            )
                        except Exception as fallback_exc:
                            logger.error(
                                f"DEBUG: Fallback AnnotatedFileData creation failed: {fallback_exc}"
                            )
                            # Optionally, skip appending if fallback also fails

            else:
                # Create basic annotations without AI analysis
                # Wrap this loop too, for consistency, although it should be fast
                basic_annotation_iterator = tqdm(
                    parsed_files,
                    desc="Preparing basic annotations",
                    unit="file",
                    total=len(parsed_files),
                    disable=config.disable_progress_bar,
                )
                for file in basic_annotation_iterator:
                    annotated_files.append(
                        AnnotatedFileData(
                            file_path=file.file_path,
                            language=file.language,
                            content=file.content,
                            annotated_content=file.content,
                            summary="",
                            tags=[],
                        )
                    )
        except Exception as e:
            raise FileProcessingError(f"Error during annotation: {str(e)}")

        # Sort files alphabetically if requested (#31)
        if config.sort_files:
            logger.info("Sorting files alphabetically by path...")
            # Debug: Check types before sorting
            for idx, item in enumerate(annotated_files):
                if not isinstance(item, AnnotatedFileData):
                    logger.error(
                        f"Type Error: Element at index {idx} in annotated_files is {type(item)}, not AnnotatedFileData. Value: {repr(item)}"
                    )
            # End Debug
            try:
                annotated_files.sort(key=lambda f: f.file_path)
            except AttributeError as e:
                logger.error(f"Error sorting files: {e}")
                raise
            logger.debug("Files sorted.")

        logger.info(f"[CodeConCat] Writing output in {config.format} format...")
        # Write output in requested format
        try:
            output = None
            if config.format == "markdown":
                output = write_markdown(
                    annotated_files, parsed_files, docs, config, folder_tree_str
                )
            elif config.format == "json":
                output = write_json(annotated_files, docs, config, folder_tree_str)
            elif config.format == "xml":
                output = write_xml(
                    parsed_files,
                    docs,
                    {f.file_path: f for f in annotated_files},
                    folder_tree_str,
                )
            elif config.format == "text":
                output = "\n".join([file.content for file in parsed_files])
        except Exception as e:
            raise OutputError(f"Error generating {config.format} output: {str(e)}")

        # --- Token stats summary (all files) ---
        try:
            from codeconcat.processor.token_counter import get_token_stats

            total_gpt4 = total_davinci = total_claude = 0
            for pf in parsed_files:
                stats = get_token_stats(pf.content)
                total_gpt4 += stats.gpt4_tokens
                total_davinci += stats.davinci_tokens
                total_claude += stats.claude_tokens
            print("\n[Token Summary] Total tokens for all parsed files:")
            print(f"  Claude:   {total_claude}")
            print(f"  GPT-4:    {total_gpt4}")
            print(f"  Davinci:  {total_davinci}")
        except Exception as e:
            logger.warning(f"[Tokens] Failed to calculate token stats: {e}")
        # Return the generated output string
        return output

    except CodeConcatError as e:
        logger.error(f"[CodeConCat] Error: {str(e)}")
        raise
    except Exception as e:
        logger.error(f"[CodeConCat] Unexpected error: {str(e)}")
        raise


def run_codeconcat_in_memory(config: CodeConCatConfig) -> str:
    """Run CodeConCat and return the output as a string, suitable for programmatic use.

    This function acts as a high-level API for integrating CodeConCat into other
    Python applications. It takes a pre-configured CodeConCatConfig object,
    runs the main processing pipeline via `run_codeconcat`, and returns the
    generated output string.

    It suppresses the default stdout messages (like the quote and final status)
    to provide a cleaner return value for programmatic callers.

    Args:
        config: A CodeConCatConfig object with all desired settings populated.

    Returns:
        The complete generated output string.

    Raises:
        Inherits exceptions from `run_codeconcat` (CodeConcatError, etc.).
    """
    # Suppress the initial quote and final messages for in-memory usage
    original_stdout = sys.stdout
    sys.stdout = open(os.devnull, "w")
    try:
        result = run_codeconcat(config)
    finally:
        # Restore stdout
        sys.stdout.close()
        sys.stdout = original_stdout
    return result


def main():
    """Main function wrapper that calls the CLI entry point."""
    cli_entry_point()


if __name__ == "__main__":
    main()
