# file: codeconcat/parser/language_parsers/tree_sitter_hlsl_parser.py

"""
Enhanced HLSL parser using tree-sitter.

Extracts declarations, resources, and HLSL-specific constructs using the
official tree-sitter-grammars/tree-sitter-hlsl grammar.

Supports HLSL for DirectX with features including:
- Constant buffers (cbuffer/tbuffer)
- Structured buffers and RWStructuredBuffers
- Textures and samplers with register assignments
- Semantics on parameters and return values
- Compute shader attributes ([numthreads])
- Vertex, pixel, and compute shader support
- UAV (Unordered Access View) resources
- HLSL-specific type modifiers and qualifiers
"""

import logging
import re
from typing import Dict, List, Optional, Set, Tuple

from tree_sitter import Node

from ...base_types import Declaration, ParseResult
from ...errors import LanguageParserError

# QueryCursor was removed in tree-sitter 0.24.0 - import it if available for backward compatibility
try:
    from tree_sitter import QueryCursor
except ImportError:
    QueryCursor = None  # type: ignore[assignment,misc]

from ..utils import get_node_location
from .base_tree_sitter_parser import BaseTreeSitterParser

logger = logging.getLogger(__name__)

# Tree-sitter queries for HLSL syntax
HLSL_QUERIES = {
    "cbuffers": """
        ; Constant buffer declarations
        (declaration
            (storage_class_specifier) @storage
            (#match? @storage "^(cbuffer|tbuffer)$")
            (struct_specifier
                name: (type_identifier) @name
                body: (field_declaration_list) @fields
            )
        ) @cbuffer_decl
    """,
    "resources": """
        ; Texture declarations
        (declaration
            type: (type_identifier) @type
            (#match? @type "^(Texture1D|Texture2D|Texture3D|TextureCube|Texture1DArray|Texture2DArray|TextureCubeArray|RWTexture1D|RWTexture2D|RWTexture3D)$")
            declarator: (identifier) @name
        ) @texture_decl

        ; Sampler declarations
        (declaration
            type: (type_identifier) @type
            (#match? @type "^(SamplerState|SamplerComparisonState)$")
            declarator: (identifier) @name
        ) @sampler_decl

        ; Structured buffer declarations
        (declaration
            type: (template_type
                name: (type_identifier) @buffer_type
                (#match? @buffer_type "^(StructuredBuffer|RWStructuredBuffer|ByteAddressBuffer|RWByteAddressBuffer|AppendStructuredBuffer|ConsumeStructuredBuffer)$")
                arguments: (template_argument_list) @template_args
            )
            declarator: (identifier) @name
        ) @buffer_decl

        ; Buffer with register
        (declaration
            type: (template_type
                name: (type_identifier) @buffer_type
            )
            declarator: (init_declarator
                declarator: (identifier) @name
                (register_specifier
                    register: (identifier) @register
                ) @register_spec
            )
        ) @buffer_with_register
    """,
    "functions": """
        ; Function definitions with semantics
        (function_definition
            type: (_) @return_type
            declarator: (function_declarator
                declarator: (identifier) @name
                parameters: (parameter_list) @params
            )
            (semantic_specifier
                semantic: (identifier) @return_semantic
            )? @semantic
            body: (compound_statement) @body
        ) @func_def

        ; Function with attributes
        (attributed_statement
            (attribute_specifier
                (attribute
                    name: (identifier) @attr_name
                    (#eq? @attr_name "numthreads")
                    arguments: (argument_list
                        (number_literal) @threads_x
                        ","
                        (number_literal) @threads_y
                        ","
                        (number_literal) @threads_z
                    ) @thread_args
                )
            ) @attr
            (function_definition
                declarator: (function_declarator
                    declarator: (identifier) @func_name
                )
            ) @compute_func
        ) @compute_shader
    """,
    "semantics": """
        ; Parameter with semantic
        (parameter_declaration
            type: (_) @param_type
            declarator: (identifier) @param_name
            (semantic_specifier
                semantic: (identifier) @param_semantic
            ) @semantic
        ) @param_with_semantic

        ; Field with semantic
        (field_declaration
            type: (_) @field_type
            declarator: (field_identifier) @field_name
            (semantic_specifier
                semantic: (identifier) @field_semantic
            ) @semantic
        ) @field_with_semantic
    """,
    "structs": """
        ; Struct definitions
        (struct_specifier
            name: (type_identifier) @name
            body: (field_declaration_list
                (field_declaration
                    type: (_) @field_type
                    declarator: (field_identifier) @field_name
                    (semantic_specifier
                        semantic: (identifier) @field_semantic
                    )? @semantic
                )*
            ) @fields
        ) @struct_def
    """,
    "globals": """
        ; Global variables
        (declaration
            (storage_class_specifier)? @storage
            type: (_) @type
            declarator: (identifier) @name
        ) @global_var

        ; Global variables with register
        (declaration
            type: (_) @type
            declarator: (init_declarator
                declarator: (identifier) @name
                (register_specifier
                    register: (identifier) @register
                ) @register_spec
            )
        ) @global_with_register
    """,
    "typedefs": """
        ; Type definitions
        (type_definition
            type: (_) @base_type
            declarator: (type_identifier) @alias
        ) @typedef
    """
}


class TreeSitterHlslParser(BaseTreeSitterParser):
    """HLSL parser using tree-sitter.

    This parser extracts HLSL-specific constructs including constant buffers,
    structured buffers, textures, samplers, and shader semantics.

    Attributes:
        language_name: Set to "hlsl"
        shader_stage: Detected shader stage (vertex/pixel/compute/hull/domain/geometry)
        _cbuffers: Cached constant buffer declarations
        _resources: Cached resource declarations (textures, buffers, samplers)
        _semantics: Cached semantic mappings
    """

    def __init__(self):
        """Initialize the HLSL parser."""
        # Try to use the new tree-sitter-hlsl package
        try:
            from tree_sitter_hlsl import language
            self._language = language()
            super().__init__("hlsl")
        except ImportError:
            # Fall back to base initialization
            super().__init__("hlsl")

        self.shader_stage: Optional[str] = None
        self._cbuffers: List[Declaration] = []
        self._resources: List[Declaration] = []
        self._semantics: Dict[str, str] = {}

    def get_queries(self) -> Dict[str, str]:
        """Returns Tree-sitter queries for HLSL.

        Returns:
            Dictionary of query names to query strings
        """
        return HLSL_QUERIES

    def _load_language(self):
        """Load the HLSL language grammar.

        Returns:
            The loaded HLSL language object.

        Raises:
            LanguageParserError: If the language cannot be loaded.
        """
        # Try to use the standalone tree-sitter-hlsl package
        try:
            from tree_sitter import Language
            import tree_sitter_hlsl

            # Get the language pointer and create a Language object
            lang_ptr = tree_sitter_hlsl.language()
            return Language(lang_ptr)
        except ImportError:
            pass

        # Fall back to tree_sitter_languages if available
        try:
            from tree_sitter_languages import get_language
            return get_language("hlsl")
        except ImportError:
            raise LanguageParserError("Failed to load HLSL language. Install tree-sitter-hlsl package.")

    def parse(self, source_code: str, file_path: str = "unknown") -> ParseResult:
        """Parse HLSL source code and extract declarations.

        Args:
            source_code: The HLSL source code to parse.
            file_path: The path to the source file.

        Returns:
            ParseResult containing declarations and imports.
        """
        # Parse the source code
        tree = self.parser.parse(bytes(source_code, "utf8"))
        root_node = tree.root_node

        # Reset caches
        self._cbuffers = []
        self._resources = []
        self._semantics = {}

        # Extract all declarations
        declarations = []
        imports = []

        # Extract constant buffers
        self._extract_cbuffers(root_node, source_code, declarations)

        # Extract resources (textures, samplers, buffers)
        self._extract_resources(root_node, source_code, declarations)

        # Extract functions
        self._extract_functions(root_node, source_code, declarations)

        # Extract structs
        self._extract_structs(root_node, source_code, declarations)

        # Extract global variables
        self._extract_globals(root_node, source_code, declarations)

        # Extract typedefs
        self._extract_typedefs(root_node, source_code, declarations)

        # Detect shader stage
        self._detect_shader_stage(root_node, source_code, declarations)

        return ParseResult(
            declarations=declarations,
            imports=imports,
            source_code=source_code,
            file_path=file_path
        )

    def _extract_cbuffers(self, root_node: Node, source_code: str, declarations: List[Declaration]) -> None:
        """Extract constant buffer declarations."""
        query = self._compile_query("cbuffers", HLSL_QUERIES["cbuffers"])
        if not query:
            return

        captures = query.captures(root_node)

        for node, capture_name in captures:
            if capture_name == "cbuffer_decl":
                name_node = self._find_child_by_capture(captures, node, "name")
                storage_node = self._find_child_by_capture(captures, node, "storage")

                if name_node:
                    storage_text = self._get_node_text(storage_node, source_code) if storage_node else "cbuffer"
                    name = self._get_node_text(name_node, source_code)

                    decl = Declaration(
                        name=name,
                        kind=storage_text,  # cbuffer or tbuffer
                        signature=self._get_node_text(node, source_code).split("{")[0] + " { ... }",
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)
                    self._cbuffers.append(decl)

    def _extract_resources(self, root_node: Node, source_code: str, declarations: List[Declaration]) -> None:
        """Extract resource declarations (textures, samplers, buffers)."""
        query = self._compile_query("resources", HLSL_QUERIES["resources"])
        if not query:
            return

        captures = query.captures(root_node)

        for node, capture_name in captures:
            if capture_name == "texture_decl":
                type_node = self._find_child_by_capture(captures, node, "type")
                name_node = self._find_child_by_capture(captures, node, "name")

                if name_node and type_node:
                    type_text = self._get_node_text(type_node, source_code)
                    is_rw = type_text.startswith("RW")
                    kind = "rw_texture" if is_rw else "texture"

                    decl = Declaration(
                        name=self._get_node_text(name_node, source_code),
                        kind=kind,
                        signature=self._get_node_text(node, source_code),
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)
                    self._resources.append(decl)

            elif capture_name == "sampler_decl":
                type_node = self._find_child_by_capture(captures, node, "type")
                name_node = self._find_child_by_capture(captures, node, "name")

                if name_node:
                    decl = Declaration(
                        name=self._get_node_text(name_node, source_code),
                        kind="sampler",
                        signature=self._get_node_text(node, source_code),
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)
                    self._resources.append(decl)

            elif capture_name == "buffer_decl":
                buffer_type_node = self._find_child_by_capture(captures, node, "buffer_type")
                name_node = self._find_child_by_capture(captures, node, "name")

                if name_node and buffer_type_node:
                    buffer_type = self._get_node_text(buffer_type_node, source_code)
                    is_rw = buffer_type.startswith("RW")
                    kind = "structured_buffer"
                    if is_rw:
                        kind = "rw_structured_buffer"
                    elif "ByteAddress" in buffer_type:
                        kind = "byte_address_buffer"

                    decl = Declaration(
                        name=self._get_node_text(name_node, source_code),
                        kind=kind,
                        signature=self._get_node_text(node, source_code),
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)
                    self._resources.append(decl)

    def _extract_functions(self, root_node: Node, source_code: str, declarations: List[Declaration]) -> None:
        """Extract function definitions."""
        query = self._compile_query("functions", HLSL_QUERIES["functions"])
        if not query:
            return

        captures = query.captures(root_node)

        # Process compute shaders with [numthreads]
        for node, capture_name in captures:
            if capture_name == "compute_shader":
                func_name_node = self._find_child_by_capture(captures, node, "func_name")
                threads_x = self._find_child_by_capture(captures, node, "threads_x")
                threads_y = self._find_child_by_capture(captures, node, "threads_y")
                threads_z = self._find_child_by_capture(captures, node, "threads_z")

                if func_name_node:
                    name = self._get_node_text(func_name_node, source_code)
                    thread_info = ""
                    if threads_x and threads_y and threads_z:
                        x = self._get_node_text(threads_x, source_code)
                        y = self._get_node_text(threads_y, source_code)
                        z = self._get_node_text(threads_z, source_code)
                        thread_info = f"[numthreads({x}, {y}, {z})]"

                    decl = Declaration(
                        name=name,
                        kind="compute_entry_point",
                        signature=f"{thread_info} {name}",
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)

        # Process regular functions
        for node, capture_name in captures:
            if capture_name == "func_def":
                name_node = self._find_child_by_capture(captures, node, "name")
                return_type_node = self._find_child_by_capture(captures, node, "return_type")
                return_semantic = self._find_child_by_capture(captures, node, "return_semantic")

                if name_node:
                    name = self._get_node_text(name_node, source_code)

                    # Detect entry point based on semantics
                    kind = "function"
                    if return_semantic:
                        semantic = self._get_node_text(return_semantic, source_code)
                        if "SV_Position" in semantic:
                            kind = "vertex_entry_point"
                        elif "SV_Target" in semantic:
                            kind = "pixel_entry_point"
                        else:
                            kind = "entry_point"

                    signature = self._get_node_text(node, source_code).split("{")[0].strip()

                    decl = Declaration(
                        name=name,
                        kind=kind,
                        signature=signature,
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)

    def _extract_structs(self, root_node: Node, source_code: str, declarations: List[Declaration]) -> None:
        """Extract struct definitions."""
        query = self._compile_query("structs", HLSL_QUERIES["structs"])
        if not query:
            return

        captures = query.captures(root_node)

        for node, capture_name in captures:
            if capture_name == "struct_def":
                name_node = self._find_child_by_capture(captures, node, "name")

                if name_node:
                    decl = Declaration(
                        name=self._get_node_text(name_node, source_code),
                        kind="struct",
                        signature=self._get_node_text(node, source_code).split("{")[0] + " { ... }",
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)

    def _extract_globals(self, root_node: Node, source_code: str, declarations: List[Declaration]) -> None:
        """Extract global variable declarations."""
        query = self._compile_query("globals", HLSL_QUERIES["globals"])
        if not query:
            return

        captures = query.captures(root_node)

        # Track which nodes we've already processed
        processed = set()

        for node, capture_name in captures:
            if capture_name in ["global_var", "global_with_register"] and node not in processed:
                # Skip if this looks like a function or struct
                node_text = self._get_node_text(node, source_code)
                if "(" in node_text or "{" in node_text:
                    continue

                type_node = self._find_child_by_capture(captures, node, "type")
                name_node = self._find_child_by_capture(captures, node, "name")
                register_node = self._find_child_by_capture(captures, node, "register")

                if name_node and type_node:
                    type_text = self._get_node_text(type_node, source_code)
                    name = self._get_node_text(name_node, source_code)

                    # Skip if already declared as a resource
                    if any(r.name == name for r in self._resources):
                        continue

                    kind = "global_variable"
                    if register_node:
                        register = self._get_node_text(register_node, source_code)
                        if register.startswith("b"):
                            kind = "constant"
                        elif register.startswith("t"):
                            kind = "srv_resource"
                        elif register.startswith("u"):
                            kind = "uav_resource"
                        elif register.startswith("s"):
                            kind = "sampler"

                    decl = Declaration(
                        name=name,
                        kind=kind,
                        signature=node_text,
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)
                    processed.add(node)

    def _extract_typedefs(self, root_node: Node, source_code: str, declarations: List[Declaration]) -> None:
        """Extract typedef declarations."""
        query = self._compile_query("typedefs", HLSL_QUERIES["typedefs"])
        if not query:
            return

        captures = query.captures(root_node)

        for node, capture_name in captures:
            if capture_name == "typedef":
                alias_node = self._find_child_by_capture(captures, node, "alias")
                base_type_node = self._find_child_by_capture(captures, node, "base_type")

                if alias_node:
                    decl = Declaration(
                        name=self._get_node_text(alias_node, source_code),
                        kind="typedef",
                        signature=self._get_node_text(node, source_code),
                        start_line=node.start_point[0] + 1,
                        end_line=node.end_point[0] + 1
                    )
                    declarations.append(decl)

    def _detect_shader_stage(self, root_node: Node, source_code: str, declarations: List[Declaration]) -> None:
        """Detect the shader stage from entry points and attributes."""
        # Check for compute shaders
        for decl in declarations:
            if decl.kind == "compute_entry_point":
                self.shader_stage = "compute"
                return
            elif decl.kind == "vertex_entry_point":
                self.shader_stage = "vertex"
                return
            elif decl.kind == "pixel_entry_point":
                self.shader_stage = "pixel"
                return

        # Default to unknown
        self.shader_stage = "unknown"

    def _find_child_by_capture(self, captures: List[tuple], parent_node: Node, capture_name: str) -> Optional[Node]:
        """Find a child node by capture name within a parent node's range."""
        for node, name in captures:
            if name == capture_name:
                # Check if this node is within the parent's range
                if (node.start_point >= parent_node.start_point and
                    node.end_point <= parent_node.end_point):
                    return node
        return None

    def _get_node_text(self, node: Node, source_code: str) -> str:
        """Extract text from a node."""
        return source_code[node.start_byte:node.end_byte]

    def _compile_query(self, query_name: str, query_str: str):
        """Compile a query with caching."""
        cache_key = ("hlsl", query_name, query_str)
        return self._compile_query_cached(cache_key)
