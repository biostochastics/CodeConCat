"""
Integration tests for reconstruction round-trip accuracy.

These tests verify that the reconstruction system can correctly parse and reconstruct
files from outputs generated by the current writers. Each test follows the pattern:
1. Create test file data
2. Generate output using actual writer
3. Reconstruct files from output
4. Verify reconstructed content matches original
"""

import tempfile
from pathlib import Path

import pytest

from codeconcat.base_types import AnnotatedFileData, CodeConCatConfig
from codeconcat.reconstruction import reconstruct_from_file
from codeconcat.writer.json_writer import write_json
from codeconcat.writer.markdown_writer import write_markdown
from codeconcat.writer.xml_writer import write_xml


@pytest.fixture
def test_files():
    """Sample test files for reconstruction."""
    return {
        "test.py": 'def hello():\n    return "Hello, World!"\n',
        "src/utils.py": "class Util:\n    pass\n",
        "README.md": "# Test Project\n\nThis is a test.\n",
    }


@pytest.fixture
def test_items(test_files):
    """Create AnnotatedFileData objects from test files."""
    items = []
    for file_path, content in test_files.items():
        # Determine language from extension
        ext = Path(file_path).suffix
        language_map = {
            ".py": "python",
            ".md": "markdown",
            ".txt": "text",
        }
        language = language_map.get(ext, "unknown")

        items.append(
            AnnotatedFileData(
                file_path=file_path,
                language=language,
                content=content,
                annotated_content=content,  # Same as content for basic tests
            )
        )
    return items


class TestMarkdownRoundTrip:
    """Test markdown format round-trip reconstruction."""

    def test_markdown_roundtrip_basic(self, test_items, test_files):
        """Test basic markdown write â†’ reconstruct cycle."""
        # 1. Generate markdown using current writer
        config = CodeConCatConfig(format="markdown", sort_files=True, no_ai_summary=True)
        markdown_output = write_markdown(test_items, config)

        # 2. Write to temp file
        with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False) as f:
            f.write(markdown_output)
            output_file = f.name

        try:
            # 3. Reconstruct files
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "markdown")

                # 4. Verify reconstruction
                assert stats["files_processed"] == len(test_files)
                assert stats["errors"] == 0
                assert stats["files_created"] == len(test_files)

                # 5. Verify content matches
                for path, expected_content in test_files.items():
                    reconstructed_path = Path(temp_dir) / path
                    assert reconstructed_path.exists(), f"File not found: {path}"
                    actual_content = reconstructed_path.read_text()
                    assert actual_content == expected_content, f"Content mismatch for {path}"
        finally:
            # Cleanup temp file
            Path(output_file).unlink(missing_ok=True)

    def test_markdown_roundtrip_unicode_paths(self):
        """Test markdown reconstruction with unicode filenames."""
        # Test with unicode characters in paths
        unicode_items = [
            AnnotatedFileData(file_path="æµ‹è¯•.py", language="python", content="# Chinese", annotated_content="# Chinese"),
            AnnotatedFileData(file_path="Ñ„Ð°Ð¹Ð».py", language="python", content="# Cyrillic", annotated_content="# Cyrillic"),
            AnnotatedFileData(file_path="test_ðŸ˜€.py", language="python", content="# Emoji", annotated_content="# Emoji"),
        ]

        config = CodeConCatConfig(format="markdown", sort_files=True, no_ai_summary=True)
        markdown_output = write_markdown(unicode_items, config)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False, encoding="utf-8") as f:
            f.write(markdown_output)
            output_file = f.name

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "markdown")

                assert stats["files_processed"] == 3
                assert stats["errors"] == 0

                # Verify files were created with correct unicode names
                assert (Path(temp_dir) / "æµ‹è¯•.py").exists()
                assert (Path(temp_dir) / "Ñ„Ð°Ð¹Ð».py").exists()
                assert (Path(temp_dir) / "test_ðŸ˜€.py").exists()
        finally:
            Path(output_file).unlink(missing_ok=True)

    def test_markdown_roundtrip_empty_file(self):
        """Test markdown reconstruction with empty file content."""
        empty_items = [
            AnnotatedFileData(file_path="empty.py", language="python", content="", annotated_content=""),
        ]

        config = CodeConCatConfig(format="markdown", sort_files=True, no_ai_summary=True)
        markdown_output = write_markdown(empty_items, config)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False) as f:
            f.write(markdown_output)
            output_file = f.name

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "markdown")

                assert stats["files_processed"] >= 1
                reconstructed_path = Path(temp_dir) / "empty.py"
                assert reconstructed_path.exists()
                assert reconstructed_path.read_text() == ""
        finally:
            Path(output_file).unlink(missing_ok=True)


class TestXMLRoundTrip:
    """Test XML format round-trip reconstruction."""

    def test_xml_roundtrip_basic(self, test_items, test_files):
        """Test basic XML write â†’ reconstruct cycle."""
        # 1. Generate XML using current writer
        config = CodeConCatConfig(format="xml", sort_files=True, no_ai_summary=True)
        xml_output = write_xml(test_items, config)

        # 2. Write to temp file
        with tempfile.NamedTemporaryFile(mode="w", suffix=".xml", delete=False) as f:
            f.write(xml_output)
            output_file = f.name

        try:
            # 3. Reconstruct files
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "xml")

                # 4. Verify reconstruction
                assert stats["files_processed"] == len(test_files)
                assert stats["errors"] == 0
                assert stats["files_created"] == len(test_files)

                # 5. Verify content matches
                for path, expected_content in test_files.items():
                    reconstructed_path = Path(temp_dir) / path
                    assert reconstructed_path.exists(), f"File not found: {path}"
                    actual_content = reconstructed_path.read_text()
                    assert actual_content == expected_content, f"Content mismatch for {path}"
        finally:
            Path(output_file).unlink(missing_ok=True)

    def test_xml_roundtrip_special_chars(self):
        """Test XML reconstruction with special characters in paths."""
        special_items = [
            AnnotatedFileData(file_path="test (copy).py", language="python", content="# Parentheses", annotated_content="# Parentheses"),
            AnnotatedFileData(file_path="test-v2.py", language="python", content="# Hyphen", annotated_content="# Hyphen"),
            AnnotatedFileData(file_path="test_new.py", language="python", content="# Underscore", annotated_content="# Underscore"),
        ]

        config = CodeConCatConfig(format="xml", sort_files=True, no_ai_summary=True)
        xml_output = write_xml(special_items, config)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".xml", delete=False) as f:
            f.write(xml_output)
            output_file = f.name

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "xml")

                assert stats["files_processed"] == 3
                assert stats["errors"] == 0

                # Verify files with special characters were created
                assert (Path(temp_dir) / "test (copy).py").exists()
                assert (Path(temp_dir) / "test-v2.py").exists()
                assert (Path(temp_dir) / "test_new.py").exists()
        finally:
            Path(output_file).unlink(missing_ok=True)


class TestJSONRoundTrip:
    """Test JSON format round-trip reconstruction."""

    def test_json_roundtrip_basic(self, test_items, test_files):
        """Test basic JSON write â†’ reconstruct cycle."""
        # 1. Generate JSON using current writer
        config = CodeConCatConfig(format="json", sort_files=True, no_ai_summary=True)
        json_output = write_json(test_items, config)

        # 2. Write to temp file
        with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as f:
            f.write(json_output)
            output_file = f.name

        try:
            # 3. Reconstruct files
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "json")

                # 4. Verify reconstruction
                assert stats["files_processed"] == len(test_files)
                assert stats["errors"] == 0
                assert stats["files_created"] == len(test_files)

                # 5. Verify content matches
                for path, expected_content in test_files.items():
                    reconstructed_path = Path(temp_dir) / path
                    assert reconstructed_path.exists(), f"File not found: {path}"
                    actual_content = reconstructed_path.read_text()
                    assert actual_content == expected_content, f"Content mismatch for {path}"
        finally:
            Path(output_file).unlink(missing_ok=True)


class TestSecurityValidation:
    """Test security validation in reconstruction."""

    def test_path_traversal_blocked_markdown(self):
        """Test that path traversal attempts are blocked in markdown."""
        malicious_markdown = """# Test

### 1. ../../../etc/passwd {#anchor}

```python
malicious content
```
"""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False) as f:
            f.write(malicious_markdown)
            output_file = f.name

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "markdown")

                # Should have errors due to path validation failure
                assert stats["errors"] > 0

                # Verify no files were written outside temp_dir
                temp_path = Path(temp_dir)
                passwd_path = temp_path.parent.parent.parent / "etc" / "passwd"
                assert not passwd_path.exists() or passwd_path.stat().st_ctime < Path(__file__).stat().st_ctime
        finally:
            Path(output_file).unlink(missing_ok=True)

    def test_path_traversal_blocked_xml(self):
        """Test that path traversal attempts are blocked in XML."""
        malicious_xml = """<?xml version="1.0" encoding="UTF-8"?>
<codeconcat>
    <content>
        <files>
            <file_entry>
                <file_metadata>
                    <path>../../../etc/passwd</path>
                    <language>text</language>
                </file_metadata>
                <file_content>malicious content</file_content>
            </file_entry>
        </files>
    </content>
</codeconcat>
"""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".xml", delete=False) as f:
            f.write(malicious_xml)
            output_file = f.name

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "xml")

                # Should have errors due to path validation failure
                assert stats["errors"] > 0
        finally:
            Path(output_file).unlink(missing_ok=True)

    def test_path_traversal_blocked_json(self):
        """Test that path traversal attempts are blocked in JSON."""
        malicious_json = """{
    "files": [
        {
            "file_path": "../../../etc/passwd",
            "language": "text",
            "content": "malicious content"
        }
    ]
}"""
        with tempfile.NamedTemporaryFile(mode="w", suffix=".json", delete=False) as f:
            f.write(malicious_json)
            output_file = f.name

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "json")

                # Should have errors due to path validation failure
                assert stats["errors"] > 0
        finally:
            Path(output_file).unlink(missing_ok=True)

    def test_legitimate_paths_allowed(self):
        """Test that legitimate relative paths are allowed."""
        items = [
            AnnotatedFileData(file_path="src/utils.py", language="python", content="# test", annotated_content="# test"),
            AnnotatedFileData(file_path="tests/test_utils.py", language="python", content="# test", annotated_content="# test"),
        ]

        config = CodeConCatConfig(format="markdown", sort_files=True, no_ai_summary=True)
        markdown_output = write_markdown(items, config)

        with tempfile.NamedTemporaryFile(mode="w", suffix=".md", delete=False) as f:
            f.write(markdown_output)
            output_file = f.name

        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                stats = reconstruct_from_file(output_file, temp_dir, "markdown")

                # Should succeed without errors
                assert stats["errors"] == 0
                assert (Path(temp_dir) / "src" / "utils.py").exists()
                assert (Path(temp_dir) / "tests" / "test_utils.py").exists()
        finally:
            Path(output_file).unlink(missing_ok=True)
